import logging

import numpy as np
import shap

from risk_policy_distillation.models.explainers.local_explainers.local_explainer import (
    LocalExplainer,
)


logger = logging.getLogger("logger")


class SHAP(LocalExplainer):

    def __init__(self, dataset_name, label_names, n_words=6, n_samples=1000):
        """
        Lime explainer for word-based explanations.
        :param dataset_name: name of the datasets
        :param label_names: list of label names
        :param n_words: number of the most important words to be extracted
        :param n_samples: neighbourhood size to be generated by LIME
        """
        super().__init__()
        self.dataset_name = dataset_name
        self.n_words = n_words
        self.n_samples = n_samples
        self.label_names = label_names

        self.tokenizer = shap.maskers.Text(r"\W")

    def explain(self, text, decisions, prediction_func):
        """
        Explain a single text input for each decision using SHAP
        :param text: textual input
        :param decisions: a list of all possible decisions in the task
        :param prediction_func: a function predicting probabilities of outcome to be explained
        :return: a Dict object where keys are possible decisions and values are lists of important words
                 extracted by SHAP supporting that decision
        """

        # there is only one word in the input
        import re

        if len(re.split(r"\W+", text)) == 1:
            probs = prediction_func([text])[0]
            res = {d: [] for d in decisions}
            res[np.argmax(probs)] = re.split(
                r"\W+", text
            )  # only one word is important for the decided class
            return res

        explainer = shap.Explainer(
            prediction_func, self.tokenizer, output_names=self.label_names
        )

        shap_values = explainer([text])
        words = shap_values.data[0]

        res = {}
        for d in decisions:
            is_important = shap_values.values[0][:, d] > 0
            supporting = self.generate_supporting_phrases(words, is_important)
            res[d] = supporting

        logger.info(f"SHAP results = {res}")

        return res

    def generate_supporting_phrases(self, words, scores):
        supporting_words = []
        running_phrase = []
        i = 0
        while i < len(scores):
            if scores[i]:
                running_phrase.append(words[i])
            else:
                if len(running_phrase):
                    save_word = " ".join(running_phrase).strip()
                    if len(save_word):
                        supporting_words.append(save_word)

                running_phrase = []

            i += 1

        return supporting_words
